#!/usr/bin/env bash
###############################################################################
# dock - macOS Dock Manager
# Minimal, predictable output. Dry-run shows the exact dockutil commands.
#
# Config (YAML):
#   apps:
#     - Google Chrome
#     - "Visual Studio Code"
#     - "System Settings"
#   downloads:           # omit -> classic + ~/Downloads + others
#     preset: classic    # classic | fan | list
#     path: "~/Downloads"
#     section: others    # apps-left | apps-right | others
#   # To disable: downloads: off
#
# Requirements (pre-installed): dockutil >= 3.0.0, yq >= 4.0.0
###############################################################################

set -euo pipefail
LC_ALL=C
VERSION="0.1.0"

DEBUG=${DEBUG:-0}
QUIET=0
log() { [[ $QUIET -eq 0 ]] && printf "%s\n" "$*"; }
warn() { printf "⚠ %s\n" "$*" >&2; }
die() {
	warn "$*"
	exit 1
}

trap 'warn "Error at line $LINENO: ${BASH_COMMAND:-?} (exit $?)"; exit 1' ERR

DRY_RUN=0
PROFILE=""
RESET_FILE=""
DOCK_CONFIG="${DOCK_CONFIG:-}"

parsed_apps=()
dl_enabled=1
dl_preset="classic"
dl_path="${HOME}/Downloads"
dl_section="others"

# ----------------------------- Version helpers -------------------------------
extract_version() {
	awk '{
    if (match($0, /[0-9]+(\.[0-9]+)+/)) { print substr($0, RSTART, RLENGTH); found=1; exit }
  } END { if (!found) print "0" }'
}

# vercomp a b -> 0 if equal, 1 if a>b, 2 if a<b
vercomp() {
	[[ "$1" == "$2" ]] && return 0

	local IFS=.
	local -a a b
	# Split versions into arrays using IFS safely
	read -r -a a <<<"$1"
	read -r -a b <<<"$2"

	local i
	local len=${#a[@]}
	((${#b[@]} > len)) && len=${#b[@]}

	for ((i = 0; i < len; i++)); do
		local x=${a[i]:-0} y=${b[i]:-0}
		((10#$x > 10#$y)) && return 1
		((10#$x < 10#$y)) && return 2
	done
	return 0
}
version_ge() {
	vercomp "$1" "$2"
	local rc=$?
	[[ $rc -eq 0 || $rc -eq 1 ]]
}

# ----------------------------- Env/Discovery ---------------------------------
ensure_macos() { [[ "$(uname -s)" == "Darwin" ]] || die "This tool supports macOS only."; }
ensure_dockutil() {
	command -v dockutil >/dev/null 2>&1 || die "dockutil missing (brew install dockutil)."
	local v
	v="$(dockutil --version 2>/dev/null | extract_version | tr -d '\r\n')"
	version_ge "$v" "3.0.0" || die "dockutil >= 3.0.0 required, found $v"
}
ensure_yq() {
	command -v yq >/dev/null 2>&1 || die "yq missing (brew install yq)."
	local v
	v="$(yq --version 2>/dev/null | extract_version | tr -d '\r\n')"
	version_ge "$v" "4.0.0" || die "yq >= 4.0.0 required, found $v"
}

find_config() {
	# Discovery priority when --file not given:
	# 1) $DOCK_CONFIG (env), 2) --profile NAME, 3) standard locations
	if [[ -n "$DOCK_CONFIG" && -f "$DOCK_CONFIG" ]]; then
		printf "%s" "$DOCK_CONFIG"
		return 0
	fi
	if [[ -n "$PROFILE" ]]; then
		local base="$HOME/.config/dock/profiles/${PROFILE}"
		for ext in yml yaml; do [[ -f "${base}.${ext}" ]] && {
			printf "%s" "${base}.${ext}"
			return 0
		}; done
	fi
	for f in "$HOME/.config/dock/config.yml" "$HOME/.config/dock/config.yaml" "/etc/dock/config.yml" "/etc/dock/config.yaml"; do
		[[ -f "$f" ]] && {
			printf "%s" "$f"
			return 0
		}
	done
	return 1
}

app_path_for() {
	local name="$1"
	# Absolute .app path
	if [[ "$name" == /*.app && -e "$name" ]]; then
		printf "%s" "$name"
		return 0
	fi
	# Bundle ID
	if [[ "$name" == bundle:* ]]; then
		local bid="${name#bundle:}" path
		path="$(mdfind "kMDItemCFBundleIdentifier == '$bid'" | head -n1 || true)"
		[[ -n "$path" && -e "$path" ]] && {
			printf "%s" "$path"
			return 0
		}
	fi
	# Typical locations
	local p
	for p in "/Applications/${name}.app" "$HOME/Applications/${name}.app" "/System/Applications/${name}.app" "/Applications/Utilities/${name}.app"; do
		[[ -e "$p" ]] && {
			printf "%s" "$p"
			return 0
		}
	done
	# Spotlight by display name
	local sp
	sp="$(mdfind "kMDItemDisplayName == '$name'" | head -n1 || true)"
	[[ -n "$sp" && -e "$sp" ]] && {
		printf "%s" "$sp"
		return 0
	}
	printf ""
}

# ------------------------------ Schema Validation ----------------------------
validate_yaml_config() {
	local f="$1"

	# Unknown top-level keys
	local unknown
	unknown="$(yq -r 'keys | map(select(. != "apps" and . != "downloads")) | .[]?' "$f" || true)"
	if [[ -n "$unknown" ]]; then
		die "Invalid config: unknown top-level key(s): ${unknown//$'\n'/, }"
	fi

	# apps: must be seq of strings if present
	if yq -e '.apps? != null' "$f" >/dev/null 2>&1; then
		yq -e '.apps | type == "!!seq"' "$f" >/dev/null 2>&1 ||
			die "Invalid config: .apps must be a YAML list"
		local nonstr_count
		nonstr_count="$(yq -r '.apps | map(select(type != "!!str")) | length' "$f")"
		if [[ "${nonstr_count:-0}" -gt 0 ]]; then
			die "Invalid config: all .apps entries must be strings"
		fi
	fi

	# downloads: may be null/absent, "off", or map with allowed keys
	if yq -e '.downloads? != null' "$f" >/dev/null 2>&1; then
		if yq -e '.downloads == "off"' "$f" >/dev/null 2>&1; then
			: # ok
		else
			yq -e '.downloads | type == "!!map"' "$f" >/dev/null 2>&1 ||
				die "Invalid config: .downloads must be a map or the string \"off\""
			# unknown keys inside downloads
			local d_unknown
			d_unknown="$(yq -r '.downloads | keys | map(select(. != "preset" and . != "path" and . != "section")) | .[]?' "$f" || true)"
			[[ -n "$d_unknown" ]] && die "Invalid config: unknown .downloads key(s): ${d_unknown//$'\n'/, }"

			# preset constraint
			if yq -e '.downloads.preset? != null' "$f" >/dev/null 2>&1; then
				yq -e '.downloads.preset | type == "!!str"' "$f" >/dev/null 2>&1 ||
					die "Invalid config: .downloads.preset must be a string"
				local preset
				preset="$(yq -r '.downloads.preset' "$f")"
				case "$preset" in
				classic | fan | list) : ;;
				*) die "Invalid config: .downloads.preset must be one of: classic, fan, list" ;;
				esac
			fi

			# section constraint
			if yq -e '.downloads.section? != null' "$f" >/dev/null 2>&1; then
				yq -e '.downloads.section | type == "!!str"' "$f" >/dev/null 2>&1 ||
					die "Invalid config: .downloads.section must be a string"
				local section
				section="$(yq -r '.downloads.section' "$f")"
				case "$section" in
				apps-left | apps-right | others) : ;;
				*) die "Invalid config: .downloads.section must be one of: apps-left, apps-right, others" ;;
				esac
			fi

			# path must be string if present
			if yq -e '.downloads.path? != null' "$f" >/dev/null 2>&1; then
				yq -e '.downloads.path | type == "!!str"' "$f" >/dev/null 2>&1 ||
					die "Invalid config: .downloads.path must be a string"
			fi
		fi
	fi
}

# ------------------------------ YAML parse -----------------------------------
load_yaml_config() {
	local f="$1"
	parsed_apps=()

	# strict validation first
	validate_yaml_config "$f"

	local out
	out="$(yq -r '.apps // [] | .[]' "$f" 2>/dev/null || true)"
	while IFS= read -r l; do [[ -n "$l" ]] && parsed_apps+=("$l"); done <<<"$out"

	local raw
	raw="$(yq -r '.downloads // ""' "$f" 2>/dev/null || true)"
	if [[ "$raw" == "off" ]]; then
		dl_enabled=0
		dl_preset="classic"
		dl_path="${HOME}/Downloads"
		dl_section="others"
		return 0
	fi
	if yq -e '.downloads | type == "!!map"' "$f" >/dev/null 2>&1; then
		dl_preset="$(yq -r '.downloads.preset // "classic"' "$f")"
		dl_path="$(yq -r '.downloads.path // "~/" + "Downloads"' "$f")"
		dl_path="${dl_path/#\~/$HOME}"
		dl_section="$(yq -r '.downloads.section // "others"' "$f")"
	fi
}

build_preset_flags() {
	case "$1" in
	classic) echo "--view grid --display folder --sort dateadded" ;;
	fan) echo "--view fan --display stack --sort dateadded" ;;
	list) echo "--view list --display folder --sort name" ;;
	*) echo "--view grid --display folder --sort dateadded" ;;
	esac
}

# ------------------------------ Dock ops -------------------------------------
add_app() {
	local app="$1" path
	path="$(app_path_for "$app")"
	if [[ -z "$path" ]]; then
		warn "App not found: $app"
		return 1
	fi
	if [[ "$DRY_RUN" -eq 1 ]]; then
		printf "[DRY-RUN] dockutil --add %q --no-restart\n" "$path"
	else
		dockutil --add "$path" --no-restart >/dev/null 2>&1
	fi
}

add_downloads() {
	[[ "$dl_enabled" -eq 1 ]] || return 0
	local flags target esc_target section
	flags="$(build_preset_flags "$dl_preset")"
	target="$dl_path"
	esc_target="$(printf '%q' "$target")"
	section="others"
	[[ "$dl_section" == apps-left || "$dl_section" == apps-right ]] && section="apps"

	if [[ "$DRY_RUN" -eq 1 ]]; then
		echo "[DRY-RUN] dockutil --add $esc_target --section $section --no-restart $flags"
	else
		# shellcheck disable=SC2086
		dockutil --add "$target" --section "$section" --no-restart $flags >/dev/null 2>&1
	fi
}

reset_dock() {
	local apps=("$@")
	if [[ "$DRY_RUN" -eq 1 ]]; then
		echo "[DRY-RUN] dockutil --remove all --no-restart"
	else
		dockutil --remove all --no-restart >/dev/null 2>&1
	fi

	if [[ "$dl_enabled" -eq 1 && "$dl_section" == "apps-left" ]]; then
		add_downloads
	fi
	local a
	for a in "${apps[@]}"; do add_app "$a"; done
	if [[ "$dl_enabled" -eq 1 && "$dl_section" == "apps-right" ]]; then
		add_downloads
	fi
	if [[ "$dl_enabled" -eq 1 && "$dl_section" == "others" ]]; then
		add_downloads
	fi

	if [[ "$DRY_RUN" -eq 1 ]]; then
		echo "[DRY-RUN] killall Dock"
	else
		killall Dock 2>/dev/null || true
	fi
}

# ----------------------------- Snapshot/Backup -------------------------------
_decode_file_url() {
	local s="$1"
	s="${s#file://}"
	s="${s%/}"
	s="${s//%20/ }"
	printf "%s" "$s"
}

_pb() { /usr/libexec/PlistBuddy -c "Print :$2" "$1" 2>/dev/null | sed 's/^ *//;s/ *$//'; }

_pb_count() {
	local out
	out="$(/usr/libexec/PlistBuddy -c "Print :$2" "$1" 2>/dev/null || true)"
	if [[ -z "$out" ]]; then
		echo 0
		return
	fi
	echo "$out" | awk 'BEGIN{n=0} /^    Dict {/ {n++} END{print n}'
}

generate_snapshot_yaml() {
	local plist="$HOME/Library/Preferences/com.apple.dock.plist"

	# Apps
	local apps=() a_count idx label url
	a_count="$(_pb_count "$plist" "persistent-apps")"
	for ((idx = 0; idx < a_count; idx++)); do
		label="$(_pb "$plist" "persistent-apps:$idx:tile-data:file-label")"
		url="$(_pb "$plist" "persistent-apps:$idx:tile-data:file-data:_CFURLString")"
		if [[ -n "$url" && "$url" == *".app"* && -n "$label" ]]; then apps+=("$label"); fi
	done

	# Downloads
	local dl_path_found="" dl_section_found=""
	local o_count oidx olabel ourl
	o_count="$(_pb_count "$plist" "persistent-others")"
	for ((oidx = 0; oidx < o_count; oidx++)); do
		olabel="$(_pb "$plist" "persistent-others:$oidx:tile-data:file-label")"
		ourl="$(_pb "$plist" "persistent-others:$oidx:tile-data:file-data:_CFURLString")"
		if [[ "$olabel" == "Downloads" || "$ourl" == *"/Downloads/"* || "$ourl" == *"/Downloads" ]]; then
			dl_path_found="$ourl"
			dl_section_found="others"
			break
		fi
	done
	if [[ -z "$dl_path_found" ]]; then
		for ((idx = 0; idx < a_count; idx++)); do
			label="$(_pb "$plist" "persistent-apps:$idx:tile-data:file-label")"
			url="$(_pb "$plist" "persistent-apps:$idx:tile-data:file-data:_CFURLString")"
			if [[ -n "$url" && "$url" != *".app"* && ("$label" == "Downloads" || "$url" == *"/Downloads/"* || "$url" == *"/Downloads") ]]; then
				dl_path_found="$url"
				if ((idx == 0)); then dl_section_found="apps-left"; else dl_section_found="apps-right"; fi
				break
			fi
		done
	fi
	local norm_dl=""
	if [[ -n "$dl_path_found" ]]; then
		norm_dl="$(_decode_file_url "$dl_path_found")"
		if [[ "$norm_dl" == "$HOME/Downloads" ]]; then
			# Produce a literal tilde path for YAML output, without relying on tilde expansion
			norm_dl="~${norm_dl#"$HOME"}"
		fi
	fi

	# Emit YAML
	echo "apps:"
	if [[ ${#apps[@]} -gt 0 ]]; then
		local a
		for a in "${apps[@]}"; do printf '  - %s\n' "$a"; done
	fi
	if [[ -n "$dl_section_found" && -n "$norm_dl" ]]; then
		cat <<EOF
downloads:
  preset: classic
  path: "$norm_dl"
  section: $dl_section_found
EOF
	else
		echo "downloads: off"
	fi
}

backup_to_file() {
	local out="$1"
	[[ -n "$out" ]] || die "backup requires --file PATH"
	local dir
	dir="$(dirname "$out")"
	[[ -d "$dir" ]] || mkdir -p "$dir"
	generate_snapshot_yaml >"$out"
	log "wrote snapshot to $out"
}

# ------------------------------- CLI -----------------------------------------
show_help() {
	cat <<'EOF'
dock - macOS Dock Manager

Usage:
  dock [--dry-run] [--file PATH] [--profile NAME] COMMAND

Commands:
  reset                 Reset Dock from a config file (or discovery)
  show                  Print current Dock app names (apps section)
  validate              Validate config and print planned actions; no changes
  backup                Write current Dock as YAML config (requires --file)

Options (general):
  --dry-run             Show what would be done, without changes
  --file, -f PATH       Config file to use (reset/validate) or to write (backup)
  --profile NAME        Use ~/.config/dock/profiles/NAME.(yml|yaml) if --file not set
  -h, --help            Show this help
  --version             Print version

Dry-run format:
  • [DRY-RUN] Would reset Dock with apps: <list>; downloads: <preset>/<section> -> <path>
  [DRY-RUN] dockutil ...
EOF
}

run_reset_with_config() {
	local cf="$1"
	[[ -f "$cf" ]] || die "Config not found: $cf"
	# Validate strictly before applying
	validate_yaml_config "$cf"
	log "dock reset using config from $cf"
	load_yaml_config "$cf"
	if [[ "$DRY_RUN" -eq 1 ]]; then
		printf "• [DRY-RUN] Would reset Dock with apps: %s; downloads: %s/%s -> %s\n" \
			"${parsed_apps[*]:-<none>}" "$dl_preset" "$dl_section" "$dl_path"
	fi
	reset_dock "${parsed_apps[@]}"
}

main() {
	ensure_macos
	ensure_dockutil
	ensure_yq

	local cmd="" args=()
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--dry-run)
			DRY_RUN=1
			shift
			;;
		-f | --file)
			RESET_FILE="$2"
			shift 2
			;;
		--profile)
			PROFILE="$2"
			shift 2
			;;
		--version)
			printf "dock %s\n" "$VERSION"
			exit 0
			;;
		-h | --help)
			show_help
			exit 0
			;;
		--*) die "Unknown option: $1" ;;
		*) if [[ -z "$cmd" ]]; then
			cmd="$1"
			shift
		else
			args+=("$1")
			shift
		fi ;;
		esac
	done

	if [[ -z "$cmd" ]]; then
		warn "No command provided."
		show_help
		exit 1
	fi

	case "$cmd" in
	show)
		/usr/libexec/PlistBuddy -c 'Print persistent-apps' "$HOME/Library/Preferences/com.apple.dock.plist" 2>/dev/null |
			/usr/bin/awk -F'= ' '/file-label/ { gsub(/"/, "", $2); print $2 }'
		;;
	validate)
		local cf=""
		if [[ -n "$RESET_FILE" ]]; then
			cf="$RESET_FILE"
		elif [[ -n "$PROFILE" ]]; then
			local p
			for ext in yml yaml; do
				p="$HOME/.config/dock/profiles/${PROFILE}.${ext}"
				[[ -f "$p" ]] && {
					cf="$p"
					break
				}
			done
		elif config_file=$(find_config); then
			cf="$config_file"
		fi
		[[ -z "$cf" ]] && die "No config found for validate. Use --file PATH or set up discovery."
		# Strict validation + preview
		validate_yaml_config "$cf"
		load_yaml_config "$cf"
		printf "Config: %s\n" "$cf"
		printf "Apps:\n"
		if [[ ${#parsed_apps[@]} -eq 0 ]]; then echo "  (none)"; else
			local a
			for a in "${parsed_apps[@]}"; do echo "  - $a"; done
		fi
		if [[ "$dl_enabled" -eq 1 ]]; then
			printf "Downloads:\n  preset: %s\n  path:   %s\n  section:%s\n" "$dl_preset" "$dl_path" "$dl_section"
		else
			echo "Downloads: off"
		fi
		;;
	reset)
		local cf=""
		if [[ -n "$RESET_FILE" ]]; then
			cf="$RESET_FILE"
		elif [[ -n "$PROFILE" ]]; then
			local p
			for ext in yml yaml; do
				p="$HOME/.config/dock/profiles/${PROFILE}.${ext}"
				[[ -f "$p" ]] && {
					cf="$p"
					break
				}
			done
		elif config_file=$(find_config); then
			cf="$config_file"
		fi
		[[ -z "$cf" ]] && die "No dock YAML config found. Use --file PATH or set up discovery."
		run_reset_with_config "$cf"
		;;
	backup)
		[[ -n "$RESET_FILE" ]] || die "backup requires --file PATH (where to write the YAML)"
		backup_to_file "$RESET_FILE"
		;;
	*)
		warn "Unknown command: $cmd"
		show_help
		exit 1
		;;
	esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
